<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>2D Roblox Multiplayer</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); overflow: hidden; color: #333; }

  /* Menu Screen */
  .menu-screen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 1000; }
  .menu-container { background: rgba(255, 255, 255, 0.95); padding: 40px; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); min-width: 500px; text-align: center; backdrop-filter: blur(10px); }
  .title { font-size: 3rem; color: #667eea; margin-bottom: 30px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); }
  .form-row { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
  .form-group { flex: 1; min-width: 200px; }
  .form-group label { display: block; margin-bottom: 8px; color: #555; font-weight: bold; text-align: left; }
  .form-group input, .form-group select { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 10px; font-size: 16px; transition: border-color 0.3s; }
  .form-group input:focus, .form-group select:focus { outline: none; border-color: #667eea; }
  .btn { background: linear-gradient(45deg, #667eea, #764ba2); border: none; padding: 15px 30px; color: white; font-size: 18px; font-weight: bold; border-radius: 10px; cursor: pointer; transition: transform 0.3s, box-shadow 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.2); margin: 5px; }
  .btn:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
  .btn-create { background: linear-gradient(45deg, #4CAF50, #45a049); }
  .btn-join { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
  .status-bar { margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 8px; font-weight: bold; }
  .rooms-container { max-height: 300px; overflow-y: auto; margin-top: 20px; }
  .room-card { display: flex; justify-content: space-between; align-items: center; padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.7); border-radius: 12px; border: 1px solid rgba(0,0,0,0.1); transition: background 0.2s; }
  .room-card:hover { background: rgba(255,255,255,0.9); }
  .room-info { text-align: left; }
  .room-name { font-weight: bold; font-size: 16px; color: #333; }
  .room-details { font-size: 12px; color: #666; margin-top: 5px; }

  /* Game Screen */
  .game-container { display: none; position: relative; width: 100vw; height: 100vh; overflow: hidden; }
  #gameCanvas { display: block; background: #87CEEB; }

  .ui-overlay { position: absolute; top: 20px; left: 20px; color: white; font-size: 18px; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); z-index: 100; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; backdrop-filter: blur(5px); }
  .controls { position: absolute; bottom: 20px; left: 20px; color: white; font-size: 14px; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); z-index: 100; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; backdrop-filter: blur(5px); }
  .top-right { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 100; }

  .btn-ghost { background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.5); color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; backdrop-filter: blur(5px); transition: background 0.2s; }
  .btn-ghost:hover { background: rgba(255,255,255,0.3); }

  .players-list { position: absolute; top: 150px; left: 20px; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; backdrop-filter: blur(5px); color: white; font-size: 14px; z-index: 100; max-height: 200px; overflow-y: auto; min-width: 150px; }
  .player-item { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.2); }

  @media (max-width: 768px) {
    .menu-container { min-width: 90%; padding: 30px 20px; }
    .title { font-size: 2.5rem; }
    .form-row { flex-direction: column; }
  }
</style>
</head>
<body>

<!-- Menu Screen -->
<div id="menu" class="menu-screen">
  <div class="menu-container">
    <h1 class="title">üå∏ Boat </h1>
    <div class="form-row">
      <div class="form-group">
        <label>Your Name:</label>
        <input id="playerName" placeholder="Enter your name" maxlength="20" />
      </div>
    </div>
    <div class="form-row">
      <div class="form-group">
        <label>World Name:</label>
        <input id="worldName" placeholder="My Awesome World" maxlength="30" />
      </div>
      <div class="form-group">
        <label>Map Type:</label>
        <select id="mapType">
          <option value="Grasslands">üå± Grasslands</option>
          <option value="Desert Oasis">üèúÔ∏è Desert Oasis</option>
          <option value="Volcanic Island">üåã Volcanic Island</option>
          <option value="Winter Wonderland">‚ùÑÔ∏è Winter Wonderland</option>
          <option value="Forest Grove">üå≤ Forest Grove</option>
          <option value="Rocky Canyon">üèîÔ∏è Rocky Canyon</option>
        </select>
      </div>
    </div>
    <div style="text-align: center;">
      <button class="btn btn-create" id="createBtn">Create World</button>
      <button class="btn" id="refreshBtn">Refresh Rooms</button>
    </div>
    <div id="statusBar" class="status-bar">Connecting to server...</div>
    <div class="rooms-container">
      <h3 style="color: #667eea; margin-bottom: 15px;">üåç Available Worlds</h3>
      <div id="roomsList">
        <div class="room-card">
          <div class="room-info">
            <div class="room-name">Loading worlds...</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Game Screen -->
<div id="game" class="game-container">
  <canvas id="gameCanvas"></canvas>
  <div class="ui-overlay">
    <div><strong id="roomInfo">Room Loading...</strong></div>
    <div>Map: <span id="currentMapType">Loading...</span></div>
    <div>Players Online: <span id="playerCount">0</span></div>
  </div>
  <div class="players-list" id="playersList">
    <strong>Players:</strong>
    <div id="playersContent">Loading...</div>
  </div>
  <div class="controls">
    <strong>Controls:</strong><br />
    WASD or Arrow Keys to move<br />
    üéÆ Explore the world with friends!
  </div>
  <div class="top-right">
    <button id="leaveBtn" class="btn-ghost">Leave World</button>
  </div>
</div>

<script>
  // ---------- Supabase Configuration ----------
  const SUPABASE_URL = "https://chumxrvwpxmxttbbvemp.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNodW14cnZ3cHhteHR0YmJ2ZW1wIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4OTIxMjcsImV4cCI6MjA3MTQ2ODEyN30.__GvVFs6SwJVKLUuz6Y7aA8R5wxDWlBeA8qhKpQrCbc";

  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // ---------- DOM Elements ----------
  const menu = document.getElementById("menu");
  const gameDiv = document.getElementById("game");
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const statusBar = document.getElementById("statusBar");
  const roomsList = document.getElementById("roomsList");
  const roomInfo = document.getElementById("roomInfo");
  const currentMapType = document.getElementById("currentMapType");
  const playerCount = document.getElementById("playerCount");
  const playersList = document.getElementById("playersList");
  const playersContent = document.getElementById("playersContent");
  const refreshBtn = document.getElementById("refreshBtn");
  const playerNameInput = document.getElementById("playerName");
  const worldNameInput = document.getElementById("worldName");
  const leaveBtn = document.getElementById("leaveBtn");

  // ---------- Game Variables ----------
  let currentRoom = null;
  let player = { id: null, name: "", x: 400, y: 300, color: '#ff6b6b', lastUpdate: 0 };
  let otherPlayers = [];
  let worldMap = [];
  let keys = {};
  let gameRunning = false;
  let camera = { x: 0, y: 0 };
  let lastPlayerFetch = 0;
  let lastPositionUpdate = 0;
  let positionUpdatePending = false;

  // Map configuration
  const mapWidth = 2000;
  const mapHeight = 1500;
  const tileSize = 64;

  // Textures
  const textures = {
    grass: '#4a7c59',
    stone: '#8b8680',
    sand: '#f4e4bc',
    water: '#4a90e2',
    lava: '#ff4757',
    snow: '#ffffff',
    dirt: '#8b4513',
    wood: '#deb887'
  };

  const mapTypeConfigs = {
    'Grasslands': { primary: 'grass', secondary: 'stone', emoji: 'üå±' },
    'Desert Oasis': { primary: 'sand', secondary: 'water', emoji: 'üèúÔ∏è' },
    'Volcanic Island': { primary: 'stone', secondary: 'lava', emoji: 'üåã' },
    'Winter Wonderland': { primary: 'snow', secondary: 'water', emoji: '‚ùÑÔ∏è' },
    'Forest Grove': { primary: 'grass', secondary: 'wood', emoji: 'üå≤' },
    'Rocky Canyon': { primary: 'stone', secondary: 'dirt', emoji: 'üèîÔ∏è' }
  };

  // Set canvas size
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // ---------- Input Handling ----------
  window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key) && document.activeElement !== playerNameInput && document.activeElement !== worldNameInput) {
      keys[key] = true;
      e.preventDefault();
    } else {
      keys[key] = true;
    }
  });
  window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keys[key] = false;
    if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key) && document.activeElement !== playerNameInput && document.activeElement !== worldNameInput) {
      e.preventDefault();
    }
  });
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  // ---------- Room Management ----------
  document.getElementById("createBtn").onclick = async () => {
    const name = document.getElementById("playerName").value.trim();
    const worldName = document.getElementById("worldName").value.trim() || "Unnamed World";
    const mapType = document.getElementById("mapType").value;

    if (!name) {
      statusBar.textContent = "Please enter your name first!";
      document.getElementById("playerName").focus();
      return;
    }
    player.name = name;

    statusBar.textContent = "Creating world...";
    try {
      const map = generateMap(Math.ceil(mapWidth / tileSize), Math.ceil(mapHeight / tileSize), mapType);
      const { data, error } = await supabase
        .from("rooms")
        .insert([{ name: worldName, map_type: mapType, map: map, created_by: name, max_players: 50 }])
        .select()
        .single();
      if (error) {
        statusBar.textContent = "Error creating world: " + error.message;
        return;
      }
      statusBar.textContent = "World created! Joining...";
      joinRoom(data.id, worldName, mapType);
    } catch (error) {
      statusBar.textContent = "Error: " + error.message;
    }
  };

  // ---------- Join Room ----------
  async function joinRoom(roomId, roomName, mapType) {
    const name = document.getElementById("playerName").value.trim();
    if (!name) {
      statusBar.textContent = "Please enter your name first!";
      document.getElementById("playerName").focus();
      return;
    }
    player.name = name;
    currentRoom = roomId;
    statusBar.textContent = "Joining world...";
    try {
      // Add player to room
      const { data, error } = await supabase
        .from("players")
        .insert([{ room_id: roomId, name: player.name, x: player.x, y: player.y, color: player.color }])
        .select()
        .single();
      if (error) {
        statusBar.textContent = "Join error: " + error.message;
        return;
      }
      player.id = data.id;
      player.color = data.color;
      // Load room data
      const { data: roomData, error: roomError } = await supabase
        .from("rooms")
        .select("*")
        .eq("id", roomId)
        .single();
      if (roomError) {
        statusBar.textContent = "Error loading world data";
        return;
      }
      worldMap = roomData.map;
      startGame(roomName || roomData.name, mapType || roomData.map_type);
    } catch (error) {
      statusBar.textContent = "Error joining world: " + error.message;
    }
  }

  // ---------- Leave Room ----------
document.getElementById("leaveBtn").onclick = async () => {
  if (player.id) {
    await supabase.from("players").delete().eq("id", player.id);
  }
  gameRunning = false;
  location.reload();
};

// ---------- Load Available Rooms ----------
async function loadRooms() {
  try {
    const { data, error } = await supabase
      .from("rooms")
      .select('id, name, map_type, created_by, max_players, created_at, players(count)')
      .order('created_at', { ascending: false })
      .limit(10);
    if (error) {
      statusBar.textContent = "Error loading rooms: " + error.message;
      return;
    }
    roomsList.innerHTML = "";
    if (!data || data.length === 0) {
      roomsList.innerHTML = `<div class="room-card"><div class="room-info"><div class="room-name">No worlds available</div><div class="room-details">Create the first world!</div></div></div>`;
      statusBar.textContent = "No worlds found. Create one!";
      return;
    }

    data.forEach(room => {
      const playerCount = room.players?.[0]?.count || 0;
      const mapConfig = mapTypeConfigs[room.map_type] || { emoji: 'üåç' };
      const roomCard = document.createElement("div");
      roomCard.className = "room-card";
      roomCard.innerHTML = `
        <div class="room-info">
          <div class="room-name">${mapConfig.emoji} ${room.name}</div>
          <div class="room-details">
            ${room.map_type} ‚Ä¢ ${playerCount}/${room.max_players} players<br />
            Created by ${room.created_by}
          </div>
        </div>
        <button class="btn btn-join" data-room-id="${room.id}" data-room-name="${room.name.replace(/"/g, '&quot;')}" data-room-type="${room.map_type}">Join</button>
      `;
      roomsList.appendChild(roomCard);
    });
    // Add event listeners to join buttons
    document.querySelectorAll('.btn-join').forEach(btn => {
      btn.onclick = () => {
        const roomId = btn.getAttribute('data-room-id');
        const roomName = btn.getAttribute('data-room-name');
        const roomType = btn.getAttribute('data-room-type');
        joinRoom(roomId, roomName, roomType);
      };
    });
    statusBar.textContent = `Found ${data.length} world(s). Choose one to join!`;
  } catch (error) {
    statusBar.textContent = "Connection error: " + error.message;
  }
}
refreshBtn.addEventListener('click', loadRooms);
loadRooms();
setInterval(loadRooms, 5000);

// ---------- Map Generation ----------
function generateMap(width, height, mapType) {
  const config = mapTypeConfigs[mapType] || mapTypeConfigs['Grasslands'];
  const map = [];
  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) + Math.sin(x * 0.05) * Math.cos(y * 0.05) * 0.5;
      let tileType;
      if (noise > 0.2) {
        tileType = config.secondary;
      } else {
        tileType = config.primary;
      }
      if (Math.random() < 0.1) {
        const texturesKeys = Object.keys(textures);
        const randTexture = texturesKeys[Math.floor(Math.random() * texturesKeys.length)];
        tileType = randTexture;
      }
      row.push(tileType);
    }
    map.push(row);
  }
  return map;
}

// ---------- Game Loop ----------
function startGame(roomName, mapType) {
  document.getElementById("menu").style.display = "none";
  document.querySelector(".game-container").style.display = "block";
  roomInfo.textContent = roomName;
  currentMapType.textContent = mapType;
  gameRunning = true;
  requestAnimationFrame(gameLoop);
  // Update player position less frequently
  setInterval(updatePlayerPosition, 100);
  // Fetch other players periodically
  setInterval(updatePlayersList, 1000);
}

// ---------- Update Player Position ----------
async function updatePlayerPosition() {
  if (player.id && positionUpdatePending) {
    try {
      await supabase
        .from("players")
        .update({ x: player.x, y: player.y })
        .eq("id", player.id);
      positionUpdatePending = false;
    } catch (error) {
      console.error("Error updating player position:", error);
    }
  }
}

// ---------- Update Other Players List ----------
async function updatePlayersList() {
  if (!currentRoom) return;
  try {
    const { data: players, error } = await supabase
      .from("players")
      .select("*")
      .eq("room_id", currentRoom);
    if (!error && players) {
      otherPlayers = players.filter(p => p.id !== player.id);
      playerCount.textContent = players.length;
      // Update display if needed (positions are from server)
      playersContent.innerHTML = otherPlayers
        .map(p => `<div class="player-item" style="color: ${p.color}">${p.name}${p.id === player.id ? ' (You)' : ''}</div>`)
        .join('');
    }
  } catch (error) {
    console.error("Error fetching players:", error);
  }
}

// ---------- Game Loop ----------
function gameLoop() {
  if (!gameRunning) return;

  // Handle movement
  let dx = 0, dy = 0;
  const speed = 10;
  if (keys['w'] || keys['arrowup']) dy -= speed;
  if (keys['s'] || keys['arrowdown']) dy += speed;
  if (keys['a'] || keys['arrowleft']) dx -= speed;
  if (keys['d'] || keys['arrowright']) dx += speed;
  if (dx !== 0 && dy !== 0) {
    dx *= 0.707;
    dy *= 0.707;
  }
  if (dx !== 0 || dy !== 0) {
    player.x = Math.max(16, Math.min(mapWidth - 16, player.x + dx));
    player.y = Math.max(16, Math.min(mapHeight - 16, player.y + dy));
    positionUpdatePending = true;
  }

  // Camera follows player
  camera.x = player.x - canvas.width / 2;
  camera.y = player.y - canvas.height / 2;
  camera.x = Math.max(0, Math.min(mapWidth - canvas.width, camera.x));
  camera.y = Math.max(0, Math.min(mapHeight - canvas.height, camera.y));

  // Render
  render();

  requestAnimationFrame(gameLoop);
}

// ---------- Rendering ----------
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();
  drawPlayers();
}

function drawMap() {
  if (!worldMap || worldMap.length === 0) return;
  const startX = Math.floor(camera.x / tileSize);
  const startY = Math.floor(camera.y / tileSize);
  const endX = Math.min(startX + Math.ceil(canvas.width / tileSize) + 1, worldMap[0].length);
  const endY = Math.min(startY + Math.ceil(canvas.height / tileSize) + 1, worldMap.length);
  for (let y = Math.max(0, startY); y < endY; y++) {
    for (let x = Math.max(0, startX); x < endX; x++) {
      const tileType = worldMap[y][x];
      const screenX = x * tileSize - camera.x;
      const screenY = y * tileSize - camera.y;

      ctx.fillStyle = textures[tileType] || textures.grass;
      ctx.fillRect(screenX, screenY, tileSize, tileSize);

      // Texture patterns (simplified)
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      if (tileType === 'grass') {
        for (let i = 0; i < 3; i++) {
          const px = screenX + Math.random() * tileSize;
          const py = screenY + Math.random() * tileSize;
          ctx.fillRect(px, py, 2, 4);
        }
      } else if (tileType === 'stone') {
        ctx.fillRect(screenX + 10, screenY + 10, 20, 20);
        ctx.fillRect(screenX + 35, screenY + 25, 15, 15);
      } else if (tileType === 'water') {
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        const wave = Math.sin(Date.now() * 0.005 + x + y) * 3;
        ctx.fillRect(screenX, screenY + wave, tileSize, 3);
      }
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      ctx.strokeRect(screenX, screenY, tileSize, tileSize);
    }
  }
}

function drawPlayers() {
  // Draw other players first
  otherPlayers.forEach(p => {
    drawPlayer(p, false);
  });
  // Draw current player on top
  drawPlayer(player, true);
}

function drawPlayer(p, isCurrentPlayer) {
  const screenX = p.x - camera.x;
  const screenY = p.y - camera.y;
  const size = 32;
  if (screenX < -size || screenX > canvas.width || screenY < -size || screenY > canvas.height) return;

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(screenX - 2, screenY + size - 2, size + 4, 6);
  ctx.fillStyle = p.color || '#ff6b6b';
  ctx.fillRect(screenX, screenY, size, size);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(screenX + 8, screenY + 8, 16, 16);
  ctx.fillStyle = '#000000';
  ctx.fillRect(screenX + 10, screenY + 12, 4, 4);
  ctx.fillRect(screenX + 18, screenY + 12, 4, 4);
  ctx.strokeStyle = isCurrentPlayer ? '#FFD700' : '#000000';
  ctx.lineWidth = isCurrentPlayer ? 3 : 2;
  ctx.strokeRect(screenX, screenY, size, size);
  ctx.fillStyle = isCurrentPlayer ? '#FFD700' : '#000000';
  ctx.font = 'bold 12px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(p.name, screenX + size/2, screenY - 5);
  ctx.textAlign = 'left';
}

// ----------- Initialize connection ---------
statusBar.textContent = "Connected! Enter your name and create or join a world.";

// ----------- Mobile controls setup -----------

// Detect if device is mobile
const isMobile = window.innerWidth <= 768;

// Create mobile control buttons if on mobile
if (isMobile) {
  const controlsContainer = document.createElement('div');
  controlsContainer.style.position = 'absolute';
  controlsContainer.style.bottom = '80px';
  controlsContainer.style.left = '50%';
  controlsContainer.style.transform = 'translateX(-50%)';
  controlsContainer.style.display = 'flex';
  controlsContainer.style.gap = '10px';
  controlsContainer.style.zIndex = '200';

  const createButton = (label, key) => {
    const btn = document.createElement('button');
    btn.innerHTML = label;
    btn.style.width = '50px';
    btn.style.height = '50px';
    btn.style.borderRadius = '50%';
    btn.style.border = 'none';
    btn.style.background = 'rgba(255,255,255,0.7)';
    btn.style.fontSize = '1.5rem';
    btn.style.cursor = 'pointer';
    // Set key on press
    const press = () => { keys[key] = true; };
    const release = () => { keys[key] = false; };
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); press(); });
    btn.addEventListener('mousedown', (e) => { e.preventDefault(); press(); });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); release(); });
    btn.addEventListener('mouseup', (e) => { e.preventDefault(); release(); });
    return btn;
  };

  // Up
  const upBtn = createButton('‚Üë', 'w');
  // Down
  const downBtn = createButton('‚Üì', 's');
  // Left
  const leftBtn = createButton('‚Üê', 'a');
  // Right
  const rightBtn = createButton('‚Üí', 'd');

  controlsContainer.appendChild(upBtn);
  controlsContainer.appendChild(downBtn);
  controlsContainer.appendChild(leftBtn);
  controlsContainer.appendChild(rightBtn);

  document.body.appendChild(controlsContainer);
}

</script>
</body>
</html>
