<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Roblox 2D - Fixed Version</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%); overflow: hidden; }
    
    /* Auth */
    .auth-screen { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 2000; background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%); }
    .auth-container { background: #fff; padding: 32px; border-radius: 16px; width: min(420px,90vw); box-shadow: 0 20px 40px rgba(255,105,180,.3); }
    .auth-container h2 { color: #d63384; margin-bottom: 20px; font-size: 1.8rem; text-align:center; }
    .form-group { margin-bottom: 14px; }
    .form-group label { display:block; margin-bottom:6px; color:#d63384; font-weight:600; }
    .form-group input, .form-group select { width:100%; padding:12px; border:2px solid #f8d7da; border-radius:8px; font-size:16px; }
    .form-group input:focus, .form-group select:focus { outline:none; border-color:#ff69b4; }
    .auth-button { width:100%; background: linear-gradient(45deg, #ff69b4, #ff1493); border:none; padding:12px; color:#fff; font-weight:700; border-radius:10px; cursor:pointer; margin:8px 0; }
    .google-btn { background: linear-gradient(45deg, #ff69b4, #db4437); }
    .auth-toggle { color:#ff69b4; text-decoration:underline; cursor:pointer; margin-top:8px; display:block; text-align:center; }
    .error-message { color:#dc3545; font-size:14px; min-height:18px; margin-top:6px; }

    /* Menu */
    .main-menu { display:none; position: fixed; inset: 0; z-index: 1500; background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%); }
    .menu-header { display:flex; justify-content:space-between; align-items:center; padding:16px 20px; background: rgba(255,255,255,.15); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,182,193,.3); }
    .menu-title { color:#fff; font-size:1.6rem; font-weight:800; text-shadow: 2px 2px 4px rgba(0,0,0,.2); }
    .user-info { display:flex; align-items:center; gap:12px; color:#fff; }
    .user-avatar { width:42px; height:42px; border-radius:50%; border:2px solid #fff; object-fit:cover; }
    .logout-btn { background: rgba(255,255,255,.3); border:1px solid #fff; color:#fff; padding:6px 12px; border-radius:8px; cursor:pointer; }
    .menu-content { display:flex; height: calc(100vh - 66px); }
    .menu-sidebar { width:280px; padding:16px; background: rgba(255,255,255,.12); backdrop-filter: blur(10px); border-right:1px solid rgba(255,182,193,.3); }
    .menu-main { flex:1; padding:16px; overflow:auto; }
    .sidebar-btn { width:100%; background: rgba(255,255,255,.15); border:1px solid rgba(255,182,193,.4); color:#fff; padding:12px; margin:8px 0; border-radius:10px; cursor:pointer; font-size:15px; transition:.2s; }
    .sidebar-btn.active, .sidebar-btn:hover { background: rgba(255,255,255,.25); transform: translateX(4px); }
    .section { display:none; }
    .section.active { display:block; }
    .section h3 { color:#fff; font-size:1.5rem; margin-bottom:10px; text-shadow: 1px 1px 2px rgba(0,0,0,.2); }
    .worlds-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(240px,1fr)); gap:14px; margin-top:10px; }
    .world-card { background: rgba(255,255,255,.15); backdrop-filter: blur(10px); border:1px solid rgba(255,182,193,.3); border-radius:14px; padding:14px; }
    .world-thumbnail { width:100%; height:110px; border-radius:10px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:22px; background: linear-gradient(45deg, #ff69b4, #ff1493); margin-bottom:8px; }
    .world-info { color:#fff; }
    .world-name { font-weight:800; }
    .world-players { font-size:13px; opacity:.9; }
    .play-world-btn { width:100%; background: linear-gradient(45deg, #ff69b4, #ff1493); border:none; padding:10px; color:#fff; font-weight:800; border-radius:8px; cursor:pointer; margin-top:8px; }
    .create-world-btn { background: linear-gradient(45deg, #ff69b4, #ff1493); border:none; padding:12px 18px; color:#fff; border-radius:10px; cursor:pointer; font-weight:800; margin:6px 0 14px; }

    /* Game */
    .game-container { display:none; position: fixed; inset: 0; }
    #gameCanvas { display:block; background:#ffc0cb; width:100vw; height:100vh; }
    .back-btn { position:absolute; top:16px; right:16px; background: rgba(255,105,180,.8); color:#fff; border:none; padding:10px 16px; border-radius:8px; cursor:pointer; z-index:100; }
    .ui-overlay { position:absolute; top:16px; left:16px; color:#fff; font-weight:700; text-shadow: 2px 2px 4px rgba(0,0,0,.6); z-index:100; }
    .controls { position:absolute; bottom:16px; left:16px; color:#fff; font-size:14px; text-shadow: 2px 2px 4px rgba(0,0,0,.6); z-index:100; }

    .modal { position:fixed; inset:0; background: rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:3000; }
    .modal-content { background:#fff; padding:20px; border-radius:12px; width:min(520px,92vw); }
    .modal-content h3 { margin-bottom:10px; color:#d63384; }

    @media (max-width: 768px) {
      .menu-content { flex-direction: column; }
      .menu-sidebar { width:100%; }
    }
  </style>
</head>
<body>
  <!-- AUTH -->
  <div class="auth-screen" id="authScreen">
    <div class="auth-container">
      <div id="loginForm">
        <h2>Login to Roblox 2D</h2>
        <div class="form-group"><label>Email</label><input type="email" id="loginEmail" placeholder="you@example.com" /></div>
        <div class="form-group"><label>Password</label><input type="password" id="loginPassword" placeholder="••••••••" /></div>
        <button class="auth-button" id="loginBtn">Login</button>
        <button class="auth-button google-btn" id="googleBtn">Sign in with Google</button>
        <span class="auth-toggle" id="toRegister">Don't have an account? Register</span>
        <div class="error-message" id="loginError"></div>
      </div>

      <div id="registerForm" style="display:none;">
        <h2>Register for Roblox 2D</h2>
        <div class="form-group"><label>Username</label><input type="text" id="registerUsername" placeholder="Display name" /></div>
        <div class="form-group"><label>Email</label><input type="email" id="registerEmail" placeholder="you@example.com" /></div>
        <div class="form-group"><label>Password</label><input type="password" id="registerPassword" placeholder="At least 6 characters" /></div>
        <button class="auth-button" id="registerBtn">Register</button>
        <button class="auth-button google-btn" id="googleBtn2">Sign in with Google</button>
        <span class="auth-toggle" id="toLogin">Already have an account? Login</span>
        <div class="error-message" id="registerError"></div>
      </div>
    </div>
  </div>

  <!-- MENU -->
  <div class="main-menu" id="mainMenu">
    <div class="menu-header">
      <div class="menu-title">Roblox 2D</div>
      <div class="user-info">
        <img id="userAvatar" class="user-avatar" src="https://via.placeholder.com/80" alt="avatar" />
        <div>
          <div id="userName">—</div>
          <div id="userEmail" style="font-size:12px; opacity:.8;">—</div>
        </div>
        <button class="logout-btn" id="logoutBtn">Logout</button>
      </div>
    </div>
    <div class="menu-content">
      <div class="menu-sidebar">
        <button class="sidebar-btn active" onclick="showSection(event,'myWorlds')">My Worlds</button>
        <button class="sidebar-btn" onclick="showSection(event,'publicWorlds')">Public Worlds</button>
        <button class="sidebar-btn" onclick="showSection(event,'friends')">Friends</button>
        <button class="sidebar-btn" onclick="showSection(event,'profile')">Profile</button>
      </div>
      <div class="menu-main">
        <div id="myWorlds" class="section active">
          <h3>My Worlds</h3>
          <button class="create-world-btn" onclick="showCreateWorldModal()">+ Create New World</button>
          <div class="worlds-grid" id="myWorldsGrid"><p style="color:#fff">Loading your worlds…</p></div>
        </div>
        <div id="publicWorlds" class="section">
          <h3>Public Worlds</h3>
          <div class="worlds-grid" id="publicWorldsGrid"><p style="color:#fff">Loading public worlds…</p></div>
        </div>
        <div id="friends" class="section">
          <h3>Friends</h3>
          <p style="color:#fff">Friend system coming soon!</p>
        </div>
        <div id="profile" class="section">
          <h3>Profile Settings</h3>
          <p style="color:#fff">Profile customization coming soon!</p>
        </div>
      </div>
    </div>
  </div>

  <!-- CREATE WORLD MODAL -->
  <div class="modal" id="createWorldModal">
    <div class="modal-content">
      <h3>Create New World</h3>
      <div class="form-group"><label>World Name</label><input id="worldName" placeholder="Enter world name" /></div>
      <div class="form-group"><label>World Type</label>
        <select id="worldType">
          <option value="Grasslands">Grasslands</option>
          <option value="Desert Oasis">Desert Oasis</option>
          <option value="Volcanic Island">Volcanic Island</option>
          <option value="Winter Wonderland">Winter Wonderland</option>
          <option value="Forest Grove">Forest Grove</option>
          <option value="Rocky Canyon">Rocky Canyon</option>
        </select>
      </div>
      <div class="form-group"><label><input type="checkbox" id="worldPublic" /> Make this world public</label></div>
      <button class="auth-button" onclick="createWorld()">Create World</button>
      <button class="auth-button" style="background:#666" onclick="closeCreateWorldModal()">Cancel</button>
      <div class="error-message" id="createWorldError"></div>
    </div>
  </div>

  <!-- GAME -->
  <div class="game-container" id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button class="back-btn" onclick="backToMenu()">Back to Menu</button>
    <div class="ui-overlay">
      <div>World: <span id="currentWorldName">—</span></div>
      <div>Players: <span id="playerCount">1</span>/50</div>
    </div>
    <div class="controls">Use WASD / Arrow Keys to move</div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBAffjU7-HLGsXPmdXSqjXS3KxgXxc7tBA",
      authDomain: "boat-revival.firebaseapp.com",
      projectId: "boat-revival",
      storageBucket: "boat-revival.appspot.com",
      messagingSenderId: "207519236382",
      appId: "1:207519236382:web:3a61a1b8811fd811e0c90f",
      databaseURL: "https://boat-revival-default-rtdb.firebaseio.com"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const rtdb = firebase.database();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // UI Elements
    const authScreen = document.getElementById('authScreen');
    const mainMenu = document.getElementById('mainMenu');
    const gameContainer = document.getElementById('gameContainer');
    const loginForm = document.getElementById('loginForm');
    const registerForm = document.getElementById('registerForm');
    
    // UI Helpers
    function showSection(e, name) {
      document.querySelectorAll('.sidebar-btn').forEach(b => b.classList.remove('active'));
      e.currentTarget.classList.add('active');
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      document.getElementById(name).classList.add('active');
    }

    // Auth toggles
    document.getElementById('toRegister').onclick = () => { 
      loginForm.style.display = 'none'; 
      registerForm.style.display = 'block'; 
      document.getElementById('loginError').textContent = ''; 
    };
    
    document.getElementById('toLogin').onclick = () => { 
      registerForm.style.display = 'none'; 
      loginForm.style.display = 'block'; 
      document.getElementById('registerError').textContent = ''; 
    };

    // Auth buttons
    document.getElementById('loginBtn').onclick = async () => {
      const email = document.getElementById('loginEmail').value.trim();
      const pass = document.getElementById('loginPassword').value;
      const err = document.getElementById('loginError');
      
      if (!email || !pass) return err.textContent = 'Please fill in all fields';
      
      try {
        await auth.signInWithEmailAndPassword(email, pass);
        err.textContent = '';
      } catch (e) { 
        err.textContent = e.message; 
      }
    };

    document.getElementById('registerBtn').onclick = async () => {
      const username = document.getElementById('registerUsername').value.trim();
      const email = document.getElementById('registerEmail').value.trim();
      const pass = document.getElementById('registerPassword').value;
      const err = document.getElementById('registerError');
      
      if (!username || !email || !pass) return err.textContent = 'Please fill in all fields';
      
      try {
        const cred = await auth.createUserWithEmailAndPassword(email, pass);
        await cred.user.updateProfile({ displayName: username });
        err.textContent = '';
      } catch (e) { 
        err.textContent = e.message; 
      }
    };

    document.getElementById('googleBtn').onclick = () => 
      auth.signInWithPopup(googleProvider).catch(e => 
        document.getElementById('loginError').textContent = e.message);
        
    document.getElementById('googleBtn2').onclick = () => 
      auth.signInWithPopup(googleProvider).catch(e => 
        document.getElementById('registerError').textContent = e.message);
        
    document.getElementById('logoutBtn').onclick = () => auth.signOut();

    // Worlds Management
    const worldsCol = db.collection('worlds');
    let myWorldsUnsubscribe = null;
    let publicWorldsUnsubscribe = null;

    async function createWorldDoc({ name, type, isPublic, owner }) {
      const worldId = Date.now().toString(36) + Math.random().toString(36).substr(2);
      await worldsCol.doc(worldId).set({
        id: worldId,
        name,
        type,
        public: !!isPublic,
        owner: owner.uid,
        ownerName: owner.displayName || 'Anonymous',
        ownerPhoto: owner.photoURL || '',
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        players: 0
      });
      return worldId;
    }

    function loadMyWorlds(uid, cb) {
      if (myWorldsUnsubscribe) myWorldsUnsubscribe();
      
      return worldsCol
        .where('owner', '==', uid)
        .orderBy('createdAt', 'desc')
        .onSnapshot(snap => {
          const arr = snap.docs.map(d => ({ id: d.id, ...d.data() }));
          cb(arr);
        }, error => {
          console.error("Error loading my worlds:", error);
        });
    }

    function loadPublicWorlds(cb) {
      if (publicWorldsUnsubscribe) publicWorldsUnsubscribe();
      
      return worldsCol
        .where('public', '==', true)
        .orderBy('createdAt', 'desc')
        .onSnapshot(snap => {
          const arr = snap.docs.map(d => ({ id: d.id, ...d.data() }));
          cb(arr);
        }, error => {
          console.error("Error loading public worlds:", error);
        });
    }

    function renderWorlds(gridId, list, showOwner = false) {
      const grid = document.getElementById(gridId);
      grid.innerHTML = '';
      
      if (!list.length) { 
        grid.innerHTML = '<p style="color:#fff">No worlds yet.</p>'; 
        return; 
      }
      
      for (const w of list) {
        const el = document.createElement('div');
        el.className = 'world-card';
        el.innerHTML = `
          <div class="world-thumbnail">🌍</div>
          <div class="world-info">
            <div class="world-name">${w.name}</div>
            <div class="world-players">${w.type} • ${w.players || 0}/50 players</div>
            <div style="font-size:12px; opacity:.7; margin-top:4px;">${w.public ? 'Public' : 'Private'}${showOwner ? ` • by ${w.ownerName || 'Unknown'}` : ''}</div>
          </div>
          <button class="play-world-btn" data-id="${w.id}">Play</button>
        `;
        el.querySelector('button').onclick = () => playWorld(w);
        grid.appendChild(el);
      }
    }

    // Modal controls
    window.showCreateWorldModal = () => document.getElementById('createWorldModal').style.display = 'flex';
    window.closeCreateWorldModal = () => { 
      document.getElementById('createWorldModal').style.display = 'none'; 
      document.getElementById('worldName').value = ''; 
      document.getElementById('worldPublic').checked = false; 
      document.getElementById('createWorldError').textContent = ''; 
    };

    window.createWorld = async () => {
      const name = document.getElementById('worldName').value.trim();
      const type = document.getElementById('worldType').value;
      const isPublic = document.getElementById('worldPublic').checked;
      const err = document.getElementById('createWorldError');
      
      if (!auth.currentUser) return err.textContent = 'Not logged in';
      if (!name) return err.textContent = 'Please enter a world name';
      
      try {
        const id = await createWorldDoc({ name, type, isPublic, owner: auth.currentUser });
        closeCreateWorldModal();
      } catch(e) { 
        err.textContent = e.message; 
      }
    };

    // Game Engine
    const MAP_W = 2000, MAP_H = 1500, TILE = 64;
    const mapTypes = {
      'Grasslands': { primary: '#ffb3d9', secondary: '#ff99cc' },
      'Desert Oasis': { primary: '#ffc0cb', secondary: '#ff69b4' },
      'Volcanic Island': { primary: '#ff1493', secondary: '#dc143c' },
      'Winter Wonderland': { primary: '#ffe4e6', secondary: '#ffb3d9' },
      'Forest Grove': { primary: '#ff69b4', secondary: '#dda0dd' },
      'Rocky Canyon': { primary: '#d87093', secondary: '#db7093' }
    };

    let canvas = document.getElementById('gameCanvas');
    let ctx = canvas.getContext('2d');
    let keys = {};
    let camera = { x: 0, y: 0 };
    let player = { x: 400, y: 300, width: 32, height: 32, speed: 5, color: '#ff1493' };
    let currentWorld = null;
    let tiles = [];
    let roomRef = null, myPlayerRef = null, unsubPresence = null;
    let otherPlayers = {};
    let gameRunning = false;

    // Event listeners
    window.addEventListener('keydown', (e) => { keys[e.code] = true; });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });
    window.addEventListener('resize', resizeCanvas);

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();

    // Map generation
    function generateMap(type) {
      console.log('Generating map for type:', type);
      const cfg = mapTypes[type] || mapTypes['Grasslands'];
      tiles = [];
      const cols = Math.ceil(MAP_W / TILE);
      const rows = Math.ceil(MAP_H / TILE);

      for (let y = 0; y < rows; y++) {
        tiles[y] = [];
        for (let x = 0; x < cols; x++) {
          // Simple noise pattern for terrain variation
          const n = Math.sin(x * 0.1) * Math.cos(y * 0.1) + Math.sin(x * 0.05) * Math.cos(y * 0.05) * 0.5;
          tiles[y][x] = n > 0.2 ? cfg.secondary : cfg.primary;
        }
      }
      console.log('Map generated with', rows, 'rows and', cols, 'cols');
    }

    function handleInput() {
      if (!gameRunning) return;

      let dx = 0, dy = 0;
      if (keys['ArrowLeft'] || keys['KeyA']) dx -= player.speed;
      if (keys['ArrowRight'] || keys['KeyD']) dx += player.speed;
      if (keys['ArrowUp'] || keys['KeyW']) dy -= player.speed;
      if (keys['ArrowDown'] || keys['KeyS']) dy += player.speed;

      // Diagonal movement normalization
      if (dx && dy) {
        dx *= 0.707;
        dy *= 0.707;
      }

      // Update player position with bounds checking
      player.x = Math.max(16, Math.min(MAP_W - 16, player.x + dx));
      player.y = Math.max(16, Math.min(MAP_H - 16, player.y + dy));

      // Update camera to follow player
      camera.x = Math.max(0, Math.min(MAP_W - canvas.width, player.x - canvas.width / 2));
      camera.y = Math.max(0, Math.min(MAP_H - canvas.height, player.y - canvas.height / 2));
    }

    function drawMap() {
      if (!tiles.length) return;

      const startX = Math.floor(camera.x / TILE);
      const startY = Math.floor(camera.y / TILE);
      const endX = Math.ceil((camera.x + canvas.width) / TILE);
      const endY = Math.ceil((camera.y + canvas.height) / TILE);

      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          if (!tiles[y] || !tiles[y][x]) continue;

          ctx.fillStyle = tiles[y][x];
          ctx.fillRect(
            x * TILE - camera.x,
            y * TILE - camera.y,
            TILE,
            TILE
          );
        }
      }
    }

    function drawPlayers() {
      // Draw other players
      for (const uid in otherPlayers) {
        const p = otherPlayers[uid];
        if (!p || !p.pos) continue;

        ctx.fillStyle = p.color || '#ff69b4';
        ctx.beginPath();
        ctx.arc(p.pos.x - camera.x, p.pos.y - camera.y, 16, 0, Math.PI * 2);
        ctx.fill();

        // Player name
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(p.name || 'Player', p.pos.x - camera.x, p.pos.y - camera.y - 20);
      }

      // Draw current player
      ctx.fillStyle = player.color;
      ctx.fillRect(
        player.x - 16 - camera.x,
        player.y - 16 - camera.y,
        32,
        32
      );
    }

    let lastSend = 0;
    function maybeSendPosition() {
      const now = performance.now();
      if (now - lastSend < 50) return; // ~20 Hz
      lastSend = now;

      if (myPlayerRef) {
        myPlayerRef.update({
          pos: { x: Math.round(player.x), y: Math.round(player.y) },
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      }
    }

    function gameLoop() {
      if (!gameRunning || !currentWorld) return;

      handleInput();

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw game world
      drawMap();
      drawPlayers();

      // Send player position
      maybeSendPosition();

      requestAnimationFrame(gameLoop);
    }

    function updateWorldPlayerCount(worldId) {
      const playersRef = rtdb.ref(`rooms/${worldId}/players`);
      playersRef.on('value', async (snap) => {
        const val = snap.val() || {};
        const count = Object.keys(val).length;
        document.getElementById('playerCount').textContent = count;
        try {
          await worldsCol.doc(worldId).update({ players: count });
        } catch(e) {
          console.error('Error updating player count:', e);
        }
      });
    }

    async function joinRoom(world) {
      const uid = auth.currentUser.uid;
      roomRef = rtdb.ref(`rooms/${world.id}`);
      myPlayerRef = rtdb.ref(`rooms/${world.id}/players/${uid}`);

      const me = {
        uid,
        name: auth.currentUser.displayName || 'Anonymous',
        photo: auth.currentUser.photoURL || '',
        color: player.color,
        pos: { x: player.x, y: player.y },
        joinedAt: firebase.database.ServerValue.TIMESTAMP
      };

      await myPlayerRef.set(me);
      myPlayerRef.onDisconnect().remove();

      // Listen to other players
      const playersRef = rtdb.ref(`rooms/${world.id}/players`);
      if (unsubPresence) unsubPresence();
      
      unsubPresence = playersRef.on('value', (snap) => {
        const val = snap.val() || {};
        delete val[uid]; // Remove self
        otherPlayers = val;
      });

      updateWorldPlayerCount(world.id);
    }

    window.playWorld = async (world) => {
      console.log('Starting world:', world);
      currentWorld = world;
      document.getElementById('currentWorldName').textContent = world.name;

      // Hide menu, show game
      mainMenu.style.display = 'none';
      gameContainer.style.display = 'block';

      // Reset player position
      player.x = 400;
      player.y = 300;
      camera.x = 0;
      camera.y = 0;

      // Generate world map
      generateMap(world.type);
      resizeCanvas();

      // Join multiplayer room
      await joinRoom(world);

      // Start game loop
      gameRunning = true;
      requestAnimationFrame(gameLoop);
    };

    window.backToMenu = async () => {
      gameRunning = false;

      if (myPlayerRef) {
        try {
          await myPlayerRef.remove();
        } catch(e) {
          console.error('Error removing player:', e);
        }
      }

      if (unsubPresence) {
        rtdb.ref(`rooms/${currentWorld.id}/players`).off('value', unsubPresence);
        unsubPresence = null;
      }

      currentWorld = null;
      otherPlayers = {};
      roomRef = null;
      myPlayerRef = null;

      gameContainer.style.display = 'none';
      mainMenu.style.display = 'block';
    };

    // Auth state handler
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        // UI updates
        document.getElementById('userName').textContent = user.displayName || 'Player';
        document.getElementById('userEmail').textContent = user.email || '';
        document.getElementById('userAvatar').src = user.photoURL || 'https://via.placeholder.com/80';
        
        authScreen.style.display = 'none';
        mainMenu.style.display = 'block';

        // Load worlds data
        if (myWorldsUnsubscribe) myWorldsUnsubscribe();
        if (publicWorldsUnsubscribe) publicWorldsUnsubscribe();
        
        myWorldsUnsubscribe = loadMyWorlds(user.uid, (worlds) => {
          renderWorlds('myWorldsGrid', worlds);
        });
        
        publicWorldsUnsubscribe = loadPublicWorlds((worlds) => {
          renderWorlds('publicWorldsGrid', worlds, true);
        });
      } else {
        // Clean up
        if (myWorldsUnsubscribe) {
          myWorldsUnsubscribe();
          myWorldsUnsubscribe = null;
        }
        if (publicWorldsUnsubscribe) {
          publicWorldsUnsubscribe();
          publicWorldsUnsubscribe = null;
        }
        
        // Show auth screen
        mainMenu.style.display = 'none';
        authScreen.style.display = 'flex';
        loginForm.style.display = 'block';
        registerForm.style.display = 'none';
        
        // Clear form fields
        document.getElementById('loginEmail').value = '';
        document.getElementById('loginPassword').value = '';
        document.getElementById('registerUsername').value = '';
        document.getElementById('registerEmail').value = '';
        document.getElementById('registerPassword').value = '';
      }
    });
  </script>
</body>
</html>
