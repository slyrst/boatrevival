<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Boat</title>
  <style>
    :root {
      --bg1:#4e73df; --bg2:#1cc88a;
      --cta1:#ff6b6b; --cta2:#ee5a24;
      --text:#fff; --shadow:rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
      overflow:hidden;
    }
    .menu-screen{
      position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:1rem; background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
      z-index:1000; padding:2rem;
    }
    .title{
      font-size:4rem; color:var(--text); text-shadow:3px 3px 6px var(--shadow); margin:0 0 1rem;
      font-weight:800; letter-spacing:.5px;
    }
    .subtitle{color:rgba(255,255,255,.9); margin-bottom:.5rem}
    .form{
      display:grid; gap:.75rem; width:min(480px, 90vw); background:rgba(255,255,255,.08);
      padding:1rem; border-radius:16px; backdrop-filter: blur(4px); box-shadow:0 10px 30px var(--shadow);
    }
    .row{display:flex; gap:.75rem}
    .row > *{flex:1}
    input{
      border:none; padding:14px 16px; font-size:1rem; border-radius:12px; outline:none;
      background:rgba(255,255,255,.95);
    }
    .play-button{
      background: linear-gradient(45deg, var(--cta1), var(--cta2));
      border:none; padding:16px 24px; font-size:1.25rem; color:white; border-radius:14px; cursor:pointer;
      transition:.25s transform, .25s box-shadow; box-shadow:0 8px 20px var(--shadow); font-weight:700;
    }
    .play-button:hover{ transform: translateY(-3px); box-shadow:0 12px 28px var(--shadow);}
    .game-container{ display:none; position:relative; width:100vw; height:100vh; overflow:hidden; }
    #gameCanvas{ display:block; background:#87CEEB; }
    .ui-overlay{
      position:absolute; top:16px; left:16px; color:white; font-size:16px;
      text-shadow: 2px 2px 4px rgba(0,0,0,.7); z-index:100; line-height:1.35;
    }
    .controls{
      position:absolute; bottom:16px; left:16px; color:white; font-size:14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,.7); z-index:100;
    }
    .pill{display:inline-block; background:rgba(0,0,0,.35); padding:.25rem .5rem; border-radius:999px; font-weight:600}
  </style>
</head>
<body>
  <!-- MENU -->
  <div class="menu-screen" id="menuScreen">
    <h1 class="title">Boat</h1>
    <p class="subtitle">Create a room or join one to sail together.</p>
    <div class="form">
      <div class="row">
        <input id="displayNameInput" placeholder="Your name (e.g., CaptainBlue)" maxlength="16"/>
        <input id="roomInput" placeholder="Room ID (e.g., sea-1)" maxlength="24"/>
      </div>
      <button class="play-button" id="playBtn">PLAY</button>
      <small style="color:white; opacity:.9;">
        Tip: Share the same Room ID with friends. Max 50 players per room.
      </small>
    </div>
  </div>

  <!-- GAME -->
  <div class="game-container" id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">
      <div>Map: <span id="mapName">Loading...</span></div>
      <div>Room: <span id="roomName">—</span></div>
      <div>Players: <span id="playerCount">1</span>/50</div>
      <div class="pill" id="youTag">You: —</div>
    </div>
    <div class="controls">Move with WASD or Arrow Keys</div>
  </div>

  <!-- Firebase + Game (module) -->
  <script type="module">
    // ====== Firebase (v11 CDN, modular) ======
    // 1) Add your Firebase config here:
    const firebaseConfig = {
      apiKey: "PASTE_API_KEY",
      authDomain: "PASTE_PROJECT_ID.firebaseapp.com",
      databaseURL: "https://PASTE_PROJECT_ID-default-rtdb.firebaseio.com",
      projectId: "PASTE_PROJECT_ID",
      storageBucket: "PASTE_PROJECT_ID.appspot.com",
      messagingSenderId: "PASTE_SENDER_ID",
      appId: "PASTE_APP_ID"
    };

    // Import from Google CDN
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
    import { getDatabase, ref, onValue, onChildAdded, onChildChanged, onChildRemoved, set, update, remove, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    // ====== DOM ======
    const menuScreen = document.getElementById('menuScreen');
    const gameContainer = document.getElementById('gameContainer');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const mapNameEl = document.getElementById('mapName');
    const roomNameEl = document.getElementById('roomName');
    const playerCountEl = document.getElementById('playerCount');
    const youTagEl = document.getElementById('youTag');
    const playBtn = document.getElementById('playBtn');
    const displayNameInput = document.getElementById('displayNameInput');
    const roomInput = document.getElementById('roomInput');

    // ====== Game State ======
    let gameRunning = false;
    let camera = { x: 0, y: 0 };
    let roomId = "sea-1";
    let localUid = null;
    let localName = null;

    // World
    const mapWidth = 2000;
    const mapHeight = 1500;
    let currentMap = null;

    // Player (boat)
    const player = {
      x: 400, y: 300, width: 32, height: 32, speed: 5, color: '#ff6b6b',
      vx: 0, vy: 0
    };

    // Other players
    const others = new Map(); // uid -> {x,y,color,name}

    // Input
    const keys = {};

    // Textures
    const textures = {
      grass: '#4a7c59',
      stone: '#8b8680',
      sand: '#f4e4bc',
      water: '#4a90e2',
      lava: '#ff4757',
      snow: '#ffffff',
      dirt: '#8b4513',
      wood: '#deb887'
    };

    // Favor water maps for "Boat"
    const mapTypes = [
      { name: 'Great Blue', primary: 'water', secondary: 'sand' },
      { name: 'Island Chain', primary: 'water', secondary: 'grass' },
      { name: 'Reef Coast', primary: 'water', secondary: 'stone' },
      { name: 'Frozen Bay', primary: 'water', secondary: 'snow' }
    ];

    // ====== Helpers ======
    function randomName(){
      const adj = ['Swift','Brave','Merry','Salty','Silent','Lucky','Sunny','Stormy','Cosmic','Neon'];
      const noun = ['Sailor','Captain','Skipper','Mariner','Voyager','Wave','Gull','Anchor','Harbor','Compass'];
      return adj[Math.floor(Math.random()*adj.length)] + noun[Math.floor(Math.random()*noun.length)];
    }
    function randomColor(uid){
      // Deterministic pastel from uid
      let h=0; for(const c of (uid||"xx")) h=(h*31 + c.charCodeAt(0))%360;
      return `hsl(${h} 80% 60%)`;
    }

    // ====== Map Generation ======
    function generateRandomMap() {
      const randomMapType = mapTypes[Math.floor(Math.random() * mapTypes.length)];
      currentMap = randomMapType;
      mapNameEl.textContent = randomMapType.name;

      currentMap.tiles = [];
      const tileSize = 64;
      const tilesX = Math.ceil(mapWidth / tileSize);
      const tilesY = Math.ceil(mapHeight / tileSize);

      for (let y = 0; y < tilesY; y++) {
        currentMap.tiles[y] = [];
        for (let x = 0; x < tilesX; x++) {
          const noise = Math.sin(x*0.08)*Math.cos(y*0.08) + Math.sin(x*0.035)*Math.cos(y*0.035)*0.5;
          currentMap.tiles[y][x] = (noise > 0.15) ? randomMapType.secondary : randomMapType.primary;

          // small variation
          if (Math.random() < 0.06) {
            const keys = Object.keys(textures);
            currentMap.tiles[y][x] = keys[(x*7 + y*13 + keys.length) % keys.length];
          }
        }
      }
    }

    // ====== Rendering ======
    function render() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Tiles in view
      if (currentMap && currentMap.tiles) {
        const tileSize = 64;
        const startX = Math.floor(camera.x / tileSize);
        const startY = Math.floor(camera.y / tileSize);
        const endX = Math.min(startX + Math.ceil(canvas.width / tileSize) + 1, currentMap.tiles[0].length);
        const endY = Math.min(startY + Math.ceil(canvas.height / tileSize) + 1, currentMap.tiles.length);

        for (let y = Math.max(0, startY); y < endY; y++) {
          for (let x = Math.max(0, startX); x < endX; x++) {
            const tileType = currentMap.tiles[y][x];
            const screenX = x * tileSize - camera.x;
            const screenY = y * tileSize - camera.y;

            // Base tile
            ctx.fillStyle = textures[tileType];
            ctx.fillRect(screenX, screenY, tileSize, tileSize);

            // Water ripple line
            if (tileType === 'water') {
              ctx.fillStyle = 'rgba(255,255,255,0.25)';
              const wave = Math.sin(Date.now()*0.01 + x + y) * 5;
              ctx.fillRect(screenX, screenY + wave, tileSize, 2);
            }

            // Border
            ctx.strokeStyle = 'rgba(0,0,0,0.08)';
            ctx.lineWidth = 1;
            ctx.strokeRect(screenX, screenY, tileSize, tileSize);
          }
        }
      }

      // Draw other players (boats)
      others.forEach(p => drawBoat(p.x - camera.x, p.y - camera.y, p.color, p.name));

      // Draw you
      drawBoat(player.x - camera.x, player.y - camera.y, player.color, localName || "You", true);
    }

    function drawBoat(sx, sy, color, name, isYou=false){
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(sx - 2, sy + 28, 36, 6);

      // Hull
      ctx.fillStyle = color;
      ctx.fillRect(sx, sy, 32, 32);
      // Bow triangle
      ctx.beginPath();
      ctx.moveTo(sx+32, sy+8);
      ctx.lineTo(sx+48, sy+16);
      ctx.lineTo(sx+32, sy+24);
      ctx.closePath();
      ctx.fill();

      // Mast + sail
      ctx.fillStyle = '#2d2d2d';
      ctx.fillRect(sx+12, sy-18, 4, 18);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.moveTo(sx+16, sy-18);
      ctx.lineTo(sx+32, sy-6);
      ctx.lineTo(sx+16, sy-6);
      ctx.closePath();
      ctx.fill();

      // Outline
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(sx, sy, 32, 32);

      // Name tag
      ctx.font = '12px Arial';
      ctx.fillStyle = isYou ? 'rgba(255,255,255,1)' : 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = 'rgba(0,0,0,0.7)';
      ctx.lineWidth = 3;
      const label = name ?? '';
      ctx.strokeText(label, sx - 4, sy - 22);
      ctx.fillText(label, sx - 4, sy - 22);
    }

    // ====== Movement & Camera ======
    function handleInput() {
      let dx = 0, dy = 0;
      if (keys['ArrowLeft'] || keys['KeyA']) dx -= player.speed;
      if (keys['ArrowRight'] || keys['KeyD']) dx += player.speed;
      if (keys['ArrowUp'] || keys['KeyW']) dy -= player.speed;
      if (keys['ArrowDown'] || keys['KeyS']) dy += player.speed;

      if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }

      player.x = Math.max(16, Math.min(mapWidth  - 16, player.x + dx));
      player.y = Math.max(16, Math.min(mapHeight - 16, player.y + dy));

      camera.x = Math.max(0, Math.min(mapWidth  - canvas.width,  player.x - canvas.width/2));
      camera.y = Math.max(0, Math.min(mapHeight - canvas.height, player.y - canvas.height/2));
    }

    function gameLoop() {
      if (!gameRunning) return;
      handleInput();
      render();
      requestAnimationFrame(gameLoop);
    }

    // ====== Multiplayer (Realtime DB) ======
    function roomRef(path=''){
      return ref(db, `rooms/${roomId}/${path}`);
    }

    async function joinRoom(){
      // Put your player entry in DB and set up listeners
      const color = randomColor(localUid);
      player.color = color;

      const pRef = roomRef(`players/${localUid}`);
      await set(pRef, {
        name: localName,
        x: player.x, y: player.y, color,
        joinedAt: serverTimestamp()
      });

      // Auto-remove on disconnect
      onDisconnect(pRef).remove();

      // Player count
      onValue(roomRef('players'), snap => {
        const count = snap.exists() ? Object.keys(snap.val()).length : 0;
        playerCountEl.textContent = count;
      });

      // Listen to others
      onChildAdded(roomRef('players'), snap => {
        const uid = snap.key;
        if (uid === localUid) return;
        const v = snap.val();
        others.set(uid, { x: v.x, y: v.y, color: v.color || randomColor(uid), name: v.name || 'Sailor' });
      });
      onChildChanged(roomRef('players'), snap => {
        const uid = snap.key;
        if (uid === localUid) return;
        const v = snap.val();
        const o = others.get(uid) || {};
        others.set(uid, { ...o, x: v.x, y: v.y, color: v.color || o.color, name: v.name || o.name });
      });
      onChildRemoved(roomRef('players'), snap => {
        const uid = snap.key;
        others.delete(uid);
      });

      // Broadcast my position at 10Hz (rate-limited)
      setInterval(() => {
        update(pRef, { x: Math.round(player.x), y: Math.round(player.y) });
      }, 100);
    }

    // ====== Start Game ======
    function startGame() {
      menuScreen.style.display = 'none';
      gameContainer.style.display = 'block';

      canvas.width = innerWidth; canvas.height = innerHeight;
      generateRandomMap();

      // Start loop
      gameRunning = true;
      gameLoop();
    }

    // ====== Events ======
    window.addEventListener('keydown', e => { keys[e.code] = true; if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup',   e => { keys[e.code] = false; });
    window.addEventListener('resize',  () => { canvas.width = innerWidth; canvas.height = innerHeight; });

    // ====== UI Hookup ======
    playBtn.addEventListener('click', async () => {
      roomId = (roomInput.value || 'sea-1').toLowerCase().replace(/[^a-z0-9\-]/g,'').slice(0,24) || 'sea-1';
      localName = (displayNameInput.value || randomName()).slice(0,16);
      roomNameEl.textContent = roomId;
      youTagEl.textContent = `You: ${localName}`;

      // Sign in anonymously and set display name (local only)
      await signInAnonymously(auth);
    });

    // When authenticated, finish setup
    onAuthStateChanged(auth, async (user) => {
      if (!user) return;
      localUid = user.uid;

      try {
        // Try to set a displayName (not strictly necessary)
        if (!user.displayName && localName) {
          await updateProfile(user, { displayName: localName });
        }
      } catch {}

      startGame();
      await joinRoom();
    });

    // ====== Prevent context menu on right click ======
    window.addEventListener('contextmenu', e => e.preventDefault());
  </script>
</body>
</html>
